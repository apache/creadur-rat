/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.rat.gradle;

import static java.lang.String.format;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

import javax.inject.Inject;

import org.apache.rat.gradle.internal.RatWorkAction;
import org.apache.rat.gradle.internal.RatWorkParameters;
import org.gradle.api.DefaultTask;
import org.gradle.api.NamedDomainObjectProvider;
import org.gradle.api.Project;
import org.gradle.api.Transformer;
import org.gradle.api.artifacts.Configuration;
import org.gradle.api.artifacts.dsl.DependencyHandler;
import org.gradle.api.file.DirectoryProperty;
import org.gradle.api.file.RegularFileProperty;
import org.gradle.api.tasks.Internal;
import org.gradle.api.tasks.TaskAction;
import org.gradle.api.tasks.TaskProvider;
import org.gradle.workers.WorkQueue;
import org.gradle.workers.WorkerExecutor;
import org.jetbrains.annotations.NotNull;

/**
 * Apache RAT execution task.
 *
 * <p>Default property values are taken from the Gradle project's {@link RatExtension}, named {@code
 * rat}.
 *
 * <p>Available properties are all properties available on the {@link RatTaskProperties}, which
 * inherits its properties from {@link RatOptions}.
 */
public abstract class RatTask extends DefaultTask implements RatTaskProperties {
  @SuppressWarnings("unused")
  public RatTask() {
    RatExtension extension = getExtension();

    applyConventions(extension);

    getProjectBaseDir().convention(getProject().getLayout().getProjectDirectory());

    getReportOutputDirectory()
        .convention(getProject().getLayout().getBuildDirectory().dir("reports/" + getName()));
    getRatTxtFile().convention(getReportOutputDirectory().file("rat-report.txt"));
    getRatXmlFile().convention(getReportOutputDirectory().file("rat-report.xml"));
    getRatHtmlFile().convention(getReportOutputDirectory().file("rat-report.html"));

    // Task outputs are produced for a particular task input.
    // Task inputs consist of properties and files.
    // Unfortunately, we do not have a view to the same RAT processed files
    // _without_ fully configuring RAT.
    // Therefore, the task outputs are never up to date, leading to
    // unconditional task execution.
    getOutputs().upToDateWhen(t -> false);

    setGroup("verification");
    setDescription("Run Apache Release Audit Tool (RAT)");
  }

  /**
   * Sets up the Gradle {@link Configuration}s that allow consuming the generated report files.
   *
   * <ul>
   *   <li>{@code <task-name>XmlReportElements}, consumable
   *   <li>{@code <task-name>XmlReport}, resolvable, extends from the former
   *   <li>{@code <task-name>AllReportsElements}, consumable
   *   <li>{@code <task-name>AllReports}, resolvable, extends from the former
   * </ul>
   *
   * <p>This function is always called for the {@code rat} task. When registering a custom task of
   * type {@link RatTask}, this function can be used to set up the configurations for that task as
   * well.
   *
   * <p>This function is not called from the constructor to ensure that the configurations are
   * immediately available.
   */
  public static void setupRatTaskConfigurations(
      final TaskProvider<RatTask> ratTask, final Project project) {
    String xmlReportElements = format("%sXmlReportElements", ratTask.getName());
    NamedDomainObjectProvider<Configuration> xmlReportElementsConfig =
        project
            .getConfigurations()
            .register(
                xmlReportElements,
                c -> {
                  c.setDescription(
                      format(
                          "Consumable configuration containing the XML report file generated by the '%s' task.",
                          ratTask.getName()));
                  c.setCanBeResolved(false);
                  c.setCanBeConsumed(true);
                  c.outgoing(
                      configurationPublications ->
                          configurationPublications.artifact(
                              ratTask.flatMap(RatTask::getRatXmlFile)));
                });

    String allReportsElements = format("%sAllReportsElements", ratTask.getName());
    NamedDomainObjectProvider<Configuration> allReportsElementsConfig =
        project
            .getConfigurations()
            .register(
                allReportsElements,
                c -> {
                  c.setDescription(
                      format(
                          "Consumable configuration containing all report files generated by the '%s' task.",
                          ratTask.getName()));
                  c.setCanBeResolved(false);
                  c.setCanBeConsumed(true);
                  c.outgoing(
                      configurationPublications -> {
                        for (Transformer<RegularFileProperty, RatTask> reportFileFunction :
                            Arrays.<Transformer<RegularFileProperty, RatTask>>asList(
                                RatTask::getRatXmlFile,
                                RatTask::getRatTxtFile,
                                RatTask::getRatHtmlFile)) {
                          configurationPublications.artifact(ratTask.flatMap(reportFileFunction));
                        }
                      });
                });

    for (Function<RatTask, RegularFileProperty> reportFileFunction :
        Arrays.<Function<RatTask, RegularFileProperty>>asList(
            RatTask::getRatXmlFile, RatTask::getRatTxtFile, RatTask::getRatHtmlFile)) {
      project
          .getArtifacts()
          .add(
              allReportsElements,
              project.provider(() -> reportFileFunction.apply(ratTask.get())),
              artifact -> artifact.builtBy(ratTask));
    }

    // Add resolvable configurations, extending the consumable '*Elements' configurations.

    String xmlReport = format("%sXmlReport", ratTask.getName());
    project
        .getConfigurations()
        .register(
            xmlReport,
            c -> {
              c.setDescription(
                  format(
                      "Resolvable configuration containing the XML report file generated by the '%s' task, extends from the '%s' configuration.",
                      ratTask.getName(), xmlReportElementsConfig.getName()));
              c.setCanBeResolved(true);
              c.setCanBeConsumed(false);
              c.extendsFrom(xmlReportElementsConfig.get());
            });

    String allReports = format("%sAllReports", ratTask.getName());
    project
        .getConfigurations()
        .register(
            allReports,
            c -> {
              c.setDescription(
                  format(
                      "Resolvable configuration containing the all report files generated by the '%s' task, extends from the '%s' configuration.",
                      ratTask.getName(), allReportsElementsConfig.getName()));
              c.setCanBeResolved(true);
              c.setCanBeConsumed(false);
              c.extendsFrom(allReportsElementsConfig.get());
            });

    // Finally, map the dependencies
    DependencyHandler dependencies = project.getDependencies();
    Map<String, Object> xmlReportDependencyNotion = new HashMap<>();
    xmlReportDependencyNotion.put("path", project.getPath());
    xmlReportDependencyNotion.put("configuration", xmlReportElements);
    dependencies.add(xmlReport, dependencies.project(xmlReportDependencyNotion));
    Map<String, Object> allReportsDependencyNotion = new HashMap<>();
    allReportsDependencyNotion.put("path", project.getPath());
    allReportsDependencyNotion.put("configuration", allReportsElements);
    dependencies.add(allReports, dependencies.project(allReportsDependencyNotion));
  }

  private @NotNull RatExtension getExtension() {
    return getProject().getExtensions().getByType(RatExtension.class);
  }

  @Inject
  protected abstract WorkerExecutor getWorkerExecutor();

  @Internal
  public abstract DirectoryProperty getProjectBaseDir();

  @TaskAction
  public void check() {
    WorkQueue workQueue = getWorkerExecutor().classLoaderIsolation();

    // Execute RAT in a classloader isolation worker.
    // Some information is set using static fields in the RAT code base.
    // Classloader isolation prevents potential "collisions" or races in the case of multiple
    // Gradle projects (think: modules) running RAT at the same time / within the same build.
    workQueue.submit(RatWorkAction.class, this::applyWorkParameters);
    // Wait for RAT execution to finish.
    workQueue.await();
  }

  void applyWorkParameters(final RatWorkParameters parameters) {
    parameters.getProjectBaseDir().set(getProjectBaseDir());
    parameters.applyTaskPropertiesConventions(this);
    parameters.applyConventions(this);
  }
}
